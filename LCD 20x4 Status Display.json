[{"id":"66b1b13db94fdacb","type":"tab","label":"LCD 20x4 Status Display","disabled":false,"info":"","env":[]},{"id":"727cce71535d312b","type":"inject","z":"66b1b13db94fdacb","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"1","crontab":"","once":false,"onceDelay":"1","topic":"","payload":"","payloadType":"date","x":290,"y":320,"wires":[["f4a1276702b20fe9"]]},{"id":"f4a1276702b20fe9","type":"function","z":"66b1b13db94fdacb","name":"Format for LCD","func":"// 20x4 LCD \"Dashboard + Dynamic Ticker\"\n// -------------------------------------\n// Line 1: current date + time (always dynamic)\n// Line 2: device / title (can be updated via msg.lcdLine2)\n// Line 3: status / subtitle (can be updated via msg.lcdLine3)\n// Line 4: scrolling ticker (can be updated via msg.lcdTicker)\n//\n// This function is designed as a reusable \"renderer\":\n// - It has sensible defaults.\n// - Other Node-RED flows can change what’s displayed\n//   WITHOUT editing this code, just by setting msg.lcdLine2,\n//   msg.lcdLine3, or msg.lcdTicker.\n//\n// Example: from any other node, you can do:\n//   msg.lcdLine2 = \"Earthquake Monitor\";\n//   msg.lcdLine3 = \"All quiet\";\n//   msg.lcdTicker = \"No quakes > M4.0 in last hour.\";\n//   return msg;\n//\n// and wire that into this function.\n//\n// Tip: Use an Inject node that fires every 0.3–0.5 seconds\n// into this function for smooth ticker scrolling.\n\n\n// === USER CONFIG OPTIONS =====================================\n\n// Optional ON/OFF scheduling using msg.action.\n// Leave as false if you want the LCD ON all the time.\nconst USE_DISPLAY_SCHEDULE = false;\n\n// When to turn the display OFF (24h clock) if scheduling is enabled.\n// Example: OFF between 23:00 and 06:59.\nconst OFF_START_HOUR = 23;  // inclusive\nconst OFF_END_HOUR   = 7;   // exclusive\n\n// Default texts if nothing has been set yet:\nconst DEFAULT_LINE2  = \"Raspberry Pi LCD\";\nconst DEFAULT_LINE3  = \"Running on Node-RED\";\nconst DEFAULT_TICKER =\n  \"Made by The Dyslexic Coder! \";\n\n\n// === HELPER FUNCTIONS ========================================\n\n// Strip non-ASCII characters (HD44780-friendly) and trim later to 20 chars.\nfunction sanitize(str) {\n  // Ensure string, then keep only basic printable ASCII (space to ~).\n  return String(str || \"\").replace(/[^\\x20-\\x7E]/g, \" \");\n}\n\n// Trim to 20 characters after sanitizing (LCD width)\nfunction fit(str) {\n  return sanitize(str).substring(0, 20);\n}\n\n\n// === MAIN LOGIC ==============================================\n\n// 1) Time for line 1\n// If msg.payload is a timestamp, we use it; otherwise use \"now\".\nlet now;\nif (msg && msg.payload) {\n  try {\n    now = new Date(msg.payload);\n    if (isNaN(now.getTime())) {\n      now = new Date();\n    }\n  } catch (e) {\n    now = new Date();\n  }\n} else {\n  now = new Date();\n}\n\nconst fullDateTime = now.toLocaleString();  // e.g. \"12/9/2025, 9:47:29 PM\"\n\n\n// 2) Load previous LCD configuration from node context\n//\n// We store the \"current\" texts for lines 2–3 and the ticker in context,\n// so other flows can update them once, and this function keeps using them.\nlet lcdConfig = context.get(\"lcdConfig\");\nif (!lcdConfig || typeof lcdConfig !== \"object\") {\n  lcdConfig = {\n    line2: DEFAULT_LINE2,\n    line3: DEFAULT_LINE3,\n    ticker: DEFAULT_TICKER\n  };\n}\n\n\n// 3) Apply any dynamic overrides from the incoming message\n//\n// If the message contains lcdLine2/lcdLine3/lcdTicker, we update the config.\n// This allows other flows to \"set\" what the screen should show.\nif (typeof msg.lcdLine2 === \"string\" && msg.lcdLine2.trim() !== \"\") {\n  lcdConfig.line2 = msg.lcdLine2.trim();\n}\nif (typeof msg.lcdLine3 === \"string\" && msg.lcdLine3.trim() !== \"\") {\n  lcdConfig.line3 = msg.lcdLine3.trim();\n}\nif (typeof msg.lcdTicker === \"string\" && msg.lcdTicker.trim() !== \"\") {\n  lcdConfig.ticker = msg.lcdTicker.trim();\n}\n\n// Ensure ticker is never empty (fallback to default)\nif (!lcdConfig.ticker || lcdConfig.ticker.trim() === \"\") {\n  lcdConfig.ticker = DEFAULT_TICKER;\n}\n\n// Save config back to context so it persists for future ticks\ncontext.set(\"lcdConfig\", lcdConfig);\n\n\n// 4) Final text for each line BEFORE scrolling\n\n// Line 1: always current date/time\nconst line1 = fit(fullDateTime);\n\n// Line 2 & 3: come from config (which may have been updated by other flows)\nconst line2 = fit(lcdConfig.line2);\nconst line3 = fit(lcdConfig.line3);\n\n// Ticker source text for line 4\nconst baseTicker = String(lcdConfig.ticker);\n\n\n// 5) Scrolling ticker logic for Line 4\n//\n// We emulate a ticker by sliding a 20-character window across a long string\n// and remembering our position with node context.\nconst width = 20;  // LCD columns\n\n// Remember our place between calls\nlet offset = context.get(\"offset\") || 0;\n\n// Add a gap and repeat the string so the scroll wraps smoothly.\nconst gap = \"     \";  // 5 spaces between repetitions\nconst scrollSource = baseTicker + gap + baseTicker + gap;\n\nconst totalLen = scrollSource.length;\nif (offset >= totalLen) {\n  offset = 0;\n}\n\n// Take a 20-char \"window\" starting at offset\nlet tickerView = scrollSource.substring(offset, offset + width);\n\n// Pad with spaces if we’re at the end of the string\nif (tickerView.length < width) {\n  tickerView = tickerView + \" \".repeat(width - tickerView.length);\n}\n\n// Advance offset for next tick and save it back to context\noffset = offset + 1;\ncontext.set(\"offset\", offset);\n\n// Final text for Line 4\nconst line4 = fit(tickerView);\n\n\n// 6) Build payload array for LCD-I2C node\n//\n// The LCD-I2C node expects msg.payload to be an array of 4 objects,\n// one for each line of the 20x4 display.\nmsg.payload = [\n  {\n    // LINE 1: Date/Time\n    clear: true,\n    text: line1,\n    alignment: \"center\"\n  },\n  {\n    // LINE 2: Device / title\n    clear: false,\n    text: line2,\n    alignment: \"center\"\n  },\n  {\n    // LINE 3: Status / subtitle\n    clear: false,\n    text: line3,\n    alignment: \"center\"\n  },\n  {\n    // LINE 4: Scrolling ticker text\n    clear: false,\n    text: line4,\n    alignment: \"left\"  // ticker usually looks better left-aligned\n  }\n];\n\n\n// 7) OPTIONAL: display ON/OFF scheduling using msg.action\n//\n// If USE_DISPLAY_SCHEDULE is true, we send msg.action values:\n//   \"on\"          -> turn display ON\n//   \"off\"         -> turn display OFF\n//   \"clearscreen\" -> clear entire display (not used here)\n//\n// This does not change brightness, just whether the LCD is active.\nif (USE_DISPLAY_SCHEDULE) {\n  const hour = now.getHours();  // 0–23\n\n  if (hour >= OFF_START_HOUR || hour < OFF_END_HOUR) {\n    // Within \"quiet\" hours -> turn display OFF\n    msg.action = \"off\";\n  } else {\n    // Outside quiet hours -> ensure display is ON\n    msg.action = \"on\";\n  }\n}\n\n// If USE_DISPLAY_SCHEDULE is false, we do NOT touch msg.action,\n// so the LCD just stays ON (default behavior).\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":580,"y":320,"wires":[["f4837895838726ad","520f9dd6541b2342"]]},{"id":"f4837895838726ad","type":"LCD-I2C","z":"66b1b13db94fdacb","name":"","variant":"PCF8574","size":"20x4","x":800,"y":320,"wires":[]},{"id":"520f9dd6541b2342","type":"debug","z":"66b1b13db94fdacb","name":"debug 1","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":820,"y":380,"wires":[]},{"id":"25fdfb3f84eb175d","type":"catch","z":"66b1b13db94fdacb","name":"Catch LCD errors","scope":["f4a1276702b20fe9","f4837895838726ad","520f9dd6541b2342","79daa96060e4d19d","727cce71535d312b"],"uncaught":false,"x":300,"y":260,"wires":[["79daa96060e4d19d"]]},{"id":"79daa96060e4d19d","type":"debug","z":"66b1b13db94fdacb","name":"LCD errors","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","statusVal":"","statusType":"auto","x":520,"y":260,"wires":[]},{"id":"257bf5745d85bb65","type":"global-config","env":[],"modules":{"node-red-contrib-pcf8574-lcd":"0.1.0"}}]